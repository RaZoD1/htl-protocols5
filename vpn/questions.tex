\subsection{OpenVPN IP Address Allocation in Server Mode}

The allocation of IP addresses to OpenVPN clients in server mode depends on the chosen configuration: \texttt{net30}, \texttt{subnet}, or \texttt{p2p} (point-to-point). Below is an explanation of how the IP addresses are assigned in each mode.

\subsubsection{net30 (Default Mode up to OpenVPN 2.4)}
\begin{itemize}
    \item \textbf{Description}: Each client is assigned a dedicated /30 subnet, which reserves 4 IP addresses (one for the network, one for broadcast, and two usable addresses: one for the client and one for the server).
    \item \textbf{IP Assignment}:
    \begin{itemize}
        \item The server gets the first usable IP address in the /30 subnet.
        \item The client gets the second usable IP address.
    \end{itemize}
    \item \textbf{Example}:
    \begin{itemize}
        \item Subnet: \texttt{10.8.0.0/30}
        \item Server: \texttt{10.8.0.1}
        \item Client: \texttt{10.8.0.2}
        \item Broadcast: \texttt{10.8.0.3}
    \end{itemize}
    \item \textbf{Note}: This mode is suitable for point-to-point connections but is inefficient for a large number of clients.
\end{itemize}

\subsubsection{subnet (Default Mode since OpenVPN 2.4)}
\begin{itemize}
    \item \textbf{Description}: All clients share the same subnet as the server. This mode uses a single subnet, making it more efficient than \texttt{net30}.
    \item \textbf{IP Assignment}:
    \begin{itemize}
        \item The server gets the first IP address in the defined subnet.
        \item Clients receive IPs from the pool within the subnet.
    \end{itemize}
    \item \textbf{Example}:
    \begin{itemize}
        \item Subnet: \texttt{10.8.0.0/24}
        \item Server: \texttt{10.8.0.1}
        \item Client 1: \texttt{10.8.0.2}
        \item Client 2: \texttt{10.8.0.3}
        \item Broadcast: \texttt{10.8.0.255}
    \end{itemize}
    \item \textbf{Note}: This mode is ideal for scenarios where multiple clients need to communicate as if they are in the same LAN.
\end{itemize}

\subsubsection{p2p (Point-to-Point)}
\begin{itemize}
    \item \textbf{Description}: This configuration sets up a direct point-to-point link between the server and a client without using a subnet. IP assignment is manual or explicitly defined.
    \item \textbf{IP Assignment}:
    \begin{itemize}
        \item The server and client are each assigned a specific IP address from a defined address range.
    \end{itemize}
    \item \textbf{Example}:
    \begin{itemize}
        \item Server: \texttt{10.8.0.1}
        \item Client: \texttt{10.8.0.2}
    \end{itemize}
    \item \textbf{Note}: This mode is typically used for site-to-site VPNs.
\end{itemize}

\subsubsection{Implications of Using \texttt{net30}}
\begin{itemize}
    \item \textbf{IP Wastage}: In \texttt{net30} mode, each client gets a /30 subnet, which reserves four IP addresses per client. This leads to a waste of IP addresses, as only two addresses are actually used (one for the server and one for the client). The other two addresses in the subnet are reserved for network and broadcast.
    \item \textbf{Limited Scalability}: Since each client is allocated a separate /30 subnet, scaling the network with a large number of clients can quickly exhaust available address space. For instance, with 100 clients, you would need 400 IP addresses, which is inefficient compared to the \texttt{subnet} mode.
    \item \textbf{Complexity in Management}: Managing a large number of /30 subnets can be cumbersome and complex, especially when clients need to be connected to one another. This configuration is better suited for point-to-point connections where there is no need for direct client-to-client communication.
    \item \textbf{Use Case}: \texttt{net30} mode is ideal for point-to-point VPNs (e.g., connecting two sites) but not recommended for a network with many clients that need to communicate with each other.
\end{itemize}

\subsubsection{Enabling Communication Between Clients}
\begin{itemize}
    \item \textbf{Subnet Mode}: In \texttt{subnet} mode, clients are assigned IP addresses from the same subnet as the server. Since they are within the same network, clients can communicate directly with each other using their assigned IP addresses. 
    \item \textbf{Server Routing}: In \texttt{net30} or \texttt{p2p} modes, clients are typically isolated from one another by default. To enable client-to-client communication, the server can be configured to route traffic between clients.
    \item \textbf{Client-to-Client Directive}: In the server configuration file, you can enable the \texttt{client-to-client} directive. This directive allows OpenVPN clients to communicate directly with each other, even when using \texttt{net30} or \texttt{p2p} mode. 
    \item \textbf{Firewall Rules}: If communication is not working, ensure that the server's firewall is configured to allow traffic between clients.
\end{itemize}

\subsubsection{Summary}
\[
\begin{array}{|c|c|c|c|}
\hline
\textbf{Mode} & \textbf{Server IP} & \textbf{Client IP} & \textbf{Key Features} \\
\hline
\texttt{net30} & \text{First usable IP} & \text{Second usable IP} & \text{Separate /30 subnets for each client, IP wastage} \\
\hline
\texttt{subnet} & \text{First IP in subnet} & \text{IPs from subnet pool} & \text{Shared subnet for all clients} \\
\hline
\texttt{p2p} & \text{Manually defined} & \text{Manually defined} & \text{Direct point-to-point link} \\
\hline
\end{array}
\]

\subsection{Authentication Methods in OpenVPN Beyond Certificates}

In OpenVPN, authentication can be performed in ways other than using certificates. While certificates are commonly used for server and client authentication, additional methods can be employed to enhance security or offer more flexibility. These methods can include:

\begin{itemize}
    \item \textbf{Username and Password Authentication:} OpenVPN can be configured to authenticate clients using a combination of a username and password. This method can be used in conjunction with certificates or independently. For this, OpenVPN can integrate with external authentication backends.
    
    \item \textbf{Two-Factor Authentication (2FA):} OpenVPN can support two-factor authentication by combining the username/password method with a second authentication factor, such as a one-time password (OTP) generated by a mobile app like Google Authenticator. This increases security by requiring something the user knows (password) and something the user has (OTP).
    
    \item \textbf{Token-based Authentication:} Using external token-based services like TOTP (Time-based One-Time Password) or push notifications (e.g., via services like Duo or Authy) is another way to strengthen authentication methods in OpenVPN.
    
    \item \textbf{External Authentication Backends:} OpenVPN can be integrated with various user backends such as LDAP (Lightweight Directory Access Protocol), RADIUS (Remote Authentication Dial-In User Service), and Active Directory (AD). These backends allow centralized management of users and enhance authentication flexibility.
\end{itemize}

OpenVPN 2.0 and later versions introduce the capability to authenticate clients using a username and password in addition to certificates. To achieve this, the OpenVPN server can securely receive the username and password from the connecting client and use it as a basis for authentication.

\paragraph{Client Configuration:}  
To enable username/password authentication, the OpenVPN client configuration file must include the \texttt{auth-user-pass} directive. This instructs the client to prompt the user for a username and password, which will then be securely transmitted to the server over the TLS channel.

\paragraph{Server Configuration:}  
On the server side, OpenVPN must be configured to use an authentication plugin. This plugin can be a script, shared object, or DLL that the server will call each time a client attempts to connect. The plugin receives the username and password entered by the client and returns a success (0) or failure (1) value to the server, indicating whether the client should be allowed to connect.

\paragraph{Using Script Plugins:}  
Script plugins can be used by adding the \texttt{auth-user-pass-verify} directive to the server-side configuration file. For example:

\begin{minted}{text}
auth-user-pass-verify auth-pam.pl via-file
\end{minted}

This configuration uses the \texttt{auth-pam.pl} Perl script to authenticate users on a Linux server using a PAM (Pluggable Authentication Modules) authentication module. The \texttt{auth-pam.pl} script is included in the OpenVPN source distribution and is primarily intended for demonstration purposes. For real-world use, the \texttt{openvpn-auth-pam} shared object plugin should be used instead, as it offers better security and performance.

\paragraph{Using Shared Object or DLL Plugins:}  
Shared object (SO) or DLL plugins, which are compiled C modules, can be used to authenticate clients. For example, on Linux, the \texttt{openvpn-auth-pam} plugin can be used to authenticate clients against the PAM module by adding the following to the server configuration:

\begin{minted}{text}
plugin /usr/share/openvpn/plugin/lib/openvpn-auth-pam.so login
\end{minted}

This method is recommended for production environments because it uses a split-privilege execution model for better security. Additionally, C-compiled plugins generally perform faster than scripts.

\paragraph{Disabling Client Certificates:}  
While it is generally discouraged due to security concerns, OpenVPN can be configured to authenticate clients using only a username and password, bypassing the need for client certificates. This can be achieved by setting the \texttt{client-cert-not-required} directive on the server, which removes the requirement for a client certificate. Additionally, the \texttt{username-as-common-name} directive can be used, which treats the username as the Common Name (CN) when indexing user credentials.

However, it's important to note that disabling client certificates does not remove the need for the server's certificate. Clients still need to verify the server's certificate, so the \texttt{ca} directive should remain in the client configuration.

\paragraph{OpenVPN Access Server Authentication Methods:}  
The OpenVPN Access Server offers a range of authentication options and a user-friendly interface for managing them. It supports multiple methods including:

\begin{itemize}
    \item \textbf{Local Authentication:} Users are authenticated against the server's internal database, which can be easily managed from the Admin Web UI.
    
    \item \textbf{LDAP Authentication:} Integration with LDAP directories, such as Active Directory, allows centralized user management across multiple services.
    
    \item \textbf{RADIUS Authentication:} OpenVPN Access Server can also authenticate users via RADIUS servers, enabling centralized authentication management.
    
    \item \textbf{SAML Authentication:} SAML (Security Assertion Markup Language) enables single sign-on (SSO) and seamless integration with identity providers like Okta, Google Workspace, and others.
    
    \item \textbf{PAM Authentication:} Pluggable Authentication Modules (PAM) allow integration with various authentication systems, offering a flexible, secure solution.
\end{itemize}

These authentication methods can be configured easily through the Admin Web UI or via the command line interface using the \texttt{auth.module.type} configuration key. The Access Server allows users to configure multi-factor authentication (MFA) and combine different methods for enhanced security. For instance, users can add a secondary layer of authentication with Google Authenticator or other OTP-based solutions. The flexibility of Access Server makes it ideal for various enterprise environments with diverse security requirements.

\subsection{Compression in OpenVPN}

OpenVPN supports several types of compression, which can help reduce the size of the data being transmitted over the network. Specifically, OpenVPN utilizes the \texttt{LZO} compression algorithm by default. This algorithm is designed to provide a good balance between compression ratio and speed, making it well-suited for use in VPN connections.

\subsubsection{Compression Savings}

When compression is enabled in OpenVPN, the data is compressed before transmission, and the recipient decompresses it upon arrival. The actual savings depend on the type of data being transmitted, but typical compression ratios can range from 2:1 to 3:1, meaning that the amount of data sent over the network could be reduced by 50\% to 67\%. For example, transferring a 1 MB file could be reduced to 500 KB to 333 KB, depending on the content and the efficiency of the compression algorithm.

\subsubsection{Compression and TLS: Why It Should Be Avoided}

\subsection{Compression in OpenVPN}

OpenVPN supports several types of compression, which can help reduce the size of the data being transmitted over the network. Specifically, OpenVPN utilizes the \texttt{LZO} compression algorithm by default. This algorithm is designed to provide a good balance between compression ratio and speed, making it well-suited for use in VPN connections.

\subsubsection{Compression Savings}

When compression is enabled in OpenVPN, the data is compressed before transmission, and the recipient decompresses it upon arrival. The actual savings depend on the type of data being transmitted, but typical compression ratios can range from 2:1 to 3:1, meaning that the amount of data sent over the network could be reduced by 50\% to 67\%. For example, transferring a 1 MB file could be reduced to 500 KB to 333 KB, depending on the content and the efficiency of the compression algorithm. However, it is important to note that much of the data sent over a VPN is already compressed, such as media files (images, videos) or certain types of web content. As a result, the actual savings from compression in such cases can be minimal or nonexistent.

\subsubsection{Compression and TLS: Why It Should Be Avoided}

Despite the potential savings in bandwidth, using compression in combination with Transport Layer Security (TLS) is not recommended. This is because the combination can introduce security vulnerabilities. Specifically, a known attack, called the \textit{CRIME} attack (Compression Ratio Info-leak Made Easy), exploits the way that compression can leak information about the encrypted data. In the CRIME attack, an attacker can use compression to deduce information about the contents of encrypted communications, compromising the security of the encrypted connection.

In addition to CRIME, another known vulnerability is \textit{VORACLE} (VPN Oracle Compression Leak), which targets OpenVPN implementations. VORACLE allows an attacker to use the compressed traffic to gain insight into the plaintext data by exploiting the way OpenVPN handles compression. This further increases the risk of using compression with TLS-encrypted VPN connections.

Due to these risks, OpenVPN has disabled compression by default when using TLS, and it is generally recommended to avoid using compression with VPNs that employ strong encryption protocols like TLS.

\subsection{Client-Specific Parameters in OpenVPN}

OpenVPN provides several mechanisms for assigning client-specific parameters, allowing administrators to configure different settings and restrictions based on the client’s identity. These options enable fine-grained control over how clients interact with the VPN, such as directing clients to specific subnets, restricting access to certain servers, or applying unique routing rules. 

\subsubsection{Client-Specific Configuration via Client Configuration Files}

One of the most common ways to assign client-specific parameters is by using individual client configuration files. In these files, administrators can specify settings like IP addresses, routing options, or access controls. These files are typically located on the server and are associated with individual clients through the use of certificates or unique identifiers.

For example, a specific client can be directed to a particular subnet by adding the following directive in their configuration file:
\begin{minted}{bash}
ifconfig-push 10.8.0.10 255.255.255.0
\end{minted}
This would assign the client an IP address of \texttt{10.8.0.10} and a subnet mask of \texttt{255.255.255.0}.

\subsubsection{Using \texttt{ccd} Directory for Client-Specific Settings}

Another method for client-specific configuration is through the use of the \texttt{ccd} (Client Configuration Directory). When the OpenVPN server is configured with a \texttt{client-config-dir} directive, it will look for a directory that contains individual configuration files for each client, named after their common name (CN) in the client certificate. For instance, if a client’s certificate has the CN \texttt{client1}, their configuration would be placed in the \texttt{ccd/client1} file.

In this file, administrators can assign specific parameters, such as static IP addresses or routing rules:
\begin{minted}{bash}
# Assign a static IP address
ifconfig-push 10.8.0.10 255.255.255.0

# Push specific routes to the client
push "route 192.168.1.0 255.255.255.0"
\end{minted}
This allows clients to be directed to specific subnets or resources within the network.

\subsubsection{Restricting Access to Specific Servers}

To restrict access to certain servers or resources, OpenVPN can use access control lists (ACLs) or firewall rules applied on the server side. For instance, if a client should only be able to access certain servers in the network, the OpenVPN server configuration can be adjusted to route traffic to only those destinations.

Alternatively, firewall rules (either on the server or within the OpenVPN configuration itself) can be implemented to restrict traffic based on the client’s IP address. A simple example of a firewall rule to restrict access to a specific subnet might look like this:
\begin{minted}{bash}
# Restrict client access to specific subnet
iptables -A FORWARD -i tun0 -s 10.8.0.10 -d 192.168.2.0/24 -j ACCEPT
iptables -A FORWARD -i tun0 -s 10.8.0.10 -d 0.0.0.0/0 -j REJECT
\end{minted}
This rule would allow a specific client (\texttt{10.8.0.10}) to access only the \texttt{192.168.2.0/24} subnet, while denying all other traffic.

\subsection{Certificate Revocation List (CRL) in OpenVPN}

In OpenVPN, managing certificate revocation is crucial for maintaining security. A Certificate Revocation List (CRL) allows administrators to revoke certificates that are no longer valid or have been compromised. This ensures that clients with revoked certificates cannot access the VPN, even if they still possess valid, but invalidated, credentials.

\subsubsection{Creating a CRL for a Client Certificate}

A CRL is typically created and managed using the OpenSSL toolkit. To create a CRL for a client certificate, follow these steps:

\begin{enumerate}
    \item \textbf{Revoke the Client Certificate:} 
    First, the client certificate must be explicitly revoked. This can be done using the following OpenSSL command:
    \begin{minted}{bash}
openssl ca -revoke /path/to/client-cert.pem -keyfile /path/to/ca.key -cert /path/to/ca.crt
    \end{minted}
    This command revokes the specified client certificate by adding it to the CRL.

    \item \textbf{Generate the CRL:} 
    After revoking the certificate, the CRL must be generated to update the list of revoked certificates. Use the following command:
    \begin{minted}{bash}
openssl ca -gencrl -out /path/to/crl.pem -keyfile /path/to/ca.key -cert /path/to/ca.crt
    \end{minted}
    This command creates an updated CRL in the specified file.

    \item \textbf{Publish the CRL:} 
    Once the CRL has been generated, it needs to be made accessible to clients. The CRL file can be uploaded to a web server, so that clients can download it to check for revoked certificates.
\end{enumerate}

\subsubsection{Testing the Impact of a CRL}

To test the impact of a CRL in OpenVPN, follow these steps:

\begin{enumerate}
    \item \textbf{Configure OpenVPN to Use the CRL:} 
    In the OpenVPN server configuration file, the CRL can be specified with the \texttt{crl-verify} directive:
    \begin{minted}{bash}
crl-verify /path/to/crl.pem
    \end{minted}
    This ensures that OpenVPN will check the CRL to verify whether a client certificate is revoked during the handshake.

    \item \textbf{Test with a Revoked Certificate:} 
    Attempt to connect to the OpenVPN server using a client certificate that has been revoked. The connection should fail, as the server will check the CRL and deny access to the client with the revoked certificate.

    \item \textbf{Check the OpenVPN Logs:} 
    Review the OpenVPN server logs to ensure that the CRL was checked and that the connection attempt was correctly blocked due to the revoked certificate.
\end{enumerate}

\subsubsection{Alternative Methods for Publishing Revoked Certificates}

In addition to using a CRL, there are other methods for publishing revoked certificates, with one of the most notable being Online Certificate Status Protocol (OCSP). OCSP allows clients to check the revocation status of a certificate in real-time, rather than relying on a static list.

\subsubsection{OCSP in OpenVPN}

OCSP is an alternative to CRLs for publishing revocation status. It provides real-time certificate status checking, which is particularly useful in environments where certificate revocation needs to be known immediately, without waiting for a new CRL to be generated and published.

Although OpenVPN does not have built-in support for OCSP, it is possible to configure it with the help of external tools and servers. OpenVPN provides a script, \texttt{OCSP\_check.sh}, which can be used to integrate OCSP checks into the OpenVPN server setup. The script is available in the OpenVPN GitHub repository at the following URL: 
    
\url{https://raw.githubusercontent.com/OpenVPN/openvpn/refs/heads/master/contrib/OCSP_check/OCSP_check.sh}


This script can be used to perform OCSP checks on client certificates to ensure that they are still valid and have not been revoked. It allows the server to dynamically verify certificate status with an OCSP responder, improving security and reducing reliance on static CRLs.

\subsubsection{Comparison: CRL vs. OCSP}

\begin{enumerate}
    \item \textbf{CRL:} 
    \begin{itemize}
        \item CRLs are periodically updated and require manual distribution to clients.
        \item Clients must download the CRL to check for revoked certificates, which can introduce delays.
        \item Suitable for scenarios where certificate revocation status does not need to be checked instantly.
    \end{itemize}

    \item \textbf{OCSP:} 
    \begin{itemize}
        \item OCSP allows for real-time certificate revocation checking.
        \item Clients can query the OCSP responder dynamically during the connection process, ensuring up-to-date status.
        \item Requires additional setup and infrastructure, but provides more immediate responses compared to CRLs.
    \end{itemize}
\end{enumerate}

Both methods can be used in OpenVPN, but CRLs are more commonly supported out-of-the-box, while OCSP requires additional configuration.
